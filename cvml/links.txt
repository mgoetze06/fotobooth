################################################ fps counter on raspi cam ################################################ 
https://github.com/realizator/stereopi-fisheye-robot/blob/master/1_test.py


t0 = datetime.now()
counter = 0
avgtime = 0
# Capture frames from the camera
for frame in camera.capture_continuous(capture, format="bgra", use_video_port=True, resize=(img_width,img_height)):
    counter+=1
    cv2.imshow("pair", frame)
    key = cv2.waitKey(1) & 0xFF
    # if the `q` key was pressed, break from the loop and save last image
    if key == ord("q") :
        t1 = datetime.now()
        timediff = t1-t0
        print ("Average time between frames: " + str(avgtime))
        print ("Frames: " + str(counter) + " Time: " + str(timediff.total_seconds())+ " Average FPS: " + str(counter/timediff.total_seconds()))
        if (os.path.isdir("./scenes")==False):
            os.makedirs("./scenes")
        cv2.imwrite(filename, frame)
        exit(0)
        break


################################################ draw hands on usb camera input ################################################ 
https://github.com/make2explore/MediaPipe-On-RaspberryPi/blob/main/python-codes/mediaPipe-RaspberryPi-Hand-Pose.py


import cv2
import mediapipe as mp
mp_drawing = mp. solutions . drawing_utils
mp_hands = mp. solutions . hands

cap = cv2. VideoCapture(0)
with mp_hands. Hands (
    static_image_mode = False,
    max_num_hands = 2,
    min_detection_confidence = 0.5 ) as hands:
    while True:
        ret, frame = cap.read()
        if ret == False:
            break
        height, width, _ = frame.shape
        frame = cv2.flip(frame, 1)
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        results = hands.process(frame_rgb)

        if results.multi_hand_landmarks is not None:
            for hand_landmarks in results.multi_hand_landmarks:
                mp_drawing.draw_landmarks(
                    frame, hand_landmarks, mp_hands.HAND_CONNECTIONS,
                    mp_drawing.DrawingSpec(color=(0,255,255), thickness=3, circle_radius=5),
                    mp_drawing.DrawingSpec(color=(255,0,255), thickness=4, circle_radius=5))

        cv2.imshow('Frame',frame)
        if cv2.waitKey(1) & 0xFF == 27:
            break
cap.release()
cv2.destroyAllWindows()






################################################CASCADE CLASSIFIER################################################

https://medium.com/@vipulgote4/guide-to-make-custom-haar-cascade-xml-file-for-object-detection-with-opencv-6932e22c3f0e


def rotation(image, angleInDegrees):
    h, w = image.shape[:2]
    img_c = (w / 2, h / 2)

    rot = cv2.getRotationMatrix2D(img_c, angleInDegrees, 1)

    rad = math.radians(angleInDegrees)
    sin = math.sin(rad)
    cos = math.cos(rad)
    b_w = int((h * abs(sin)) + (w * abs(cos)))
    b_h = int((h * abs(cos)) + (w * abs(sin)))

    rot[0, 2] += ((b_w / 2) - img_c[0])
    rot[1, 2] += ((b_h / 2) - img_c[1])

    outImg = cv2.warpAffine(image, rot, (b_w, b_h), flags=cv2.INTER_LINEAR)
    return outImg
    
    
    
########################################################################
3d warp
    
    
    
// Projection 2D -> 3D matrix
        Mat A1 = (Mat_<double>(4,3) <<
            1, 0, -w/2,
            0, 1, -h/2,
            0, 0,    0,
            0, 0,    1);

// Rotation matrices around the X axis
        Mat R = (Mat_<double>(4, 4) <<
            1,          0,           0, 0,
            0, cos(alpha), -sin(alpha), 0,
            0, sin(alpha),  cos(alpha), 0,
            0,          0,           0, 1);

// Translation matrix on the Z axis 
        Mat T = (Mat_<double>(4, 4) <<
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, dist,
            0, 0, 0, 1);

// Camera Intrisecs matrix 3D -> 2D
        Mat A2 = (Mat_<double>(3,4) <<
            f, 0, w/2, 0,
            0, f, h/2, 0,
            0, 0,   1, 0);

Mat transfo = A2 * (T * (R * A1));

Mat source;
Mat destination;

warpPerspective(source, destination, transfo, source.size(), INTER_CUBIC | WARP_INVERSE_MAP);

















https://github.com/eborboihuc/rotate_3d
